# Gas Optimization: Direct Token Routing

## Overview

This document explains the gas optimization implemented in `RIFDepositerOptimized.sol` that **saves ~50,000 gas** per transaction by routing swap output tokens directly to the contract instead of to the user.

## The Problem

### Original Flow (RIFDepositer.sol)

```
User ‚Üí Transfer Input Tokens ‚Üí Contract
                ‚Üì
Contract ‚Üí Swap via Sushi Router
                ‚Üì
        RIF tokens sent to User üë§
                ‚Üì
User ‚Üí Approve Contract to pull RIF
                ‚Üì
Contract ‚Üí transferFrom(user, contract) ‚õΩ 50k gas
                ‚Üì
Contract ‚Üí Deposit to Staking
```

**Gas Waste:** The `transferFrom(msg.sender, address(this), rifReceived)` call at line 52 costs approximately **50,000 gas** for an ERC20 transfer.

### Why This Happens

The swap calldata generated by Sushi SDK uses the `sender` parameter to determine where output tokens are sent:

```javascript
// In generate-calldata.js line 55
const data = await getSwap({
  chainId: 30,
  tokenIn: tokenIn,
  tokenOut: '0x2AcC95758f8b5F583470ba265EB685a8F45fC9D5', // RIF
  sender: '0x922164BBBd36Acf9E854AcBbF32faCC949fCAEef', // ‚Üê RIF goes here
  amount: amountIn,
  maxSlippage: 0.005,
});
```

## The Solution

### Optimized Flow (RIFDepositerOptimized.sol)

```
User ‚Üí Transfer Input Tokens ‚Üí Contract
                ‚Üì
Contract ‚Üí Swap via Sushi Router
                ‚Üì
        RIF tokens sent to Contract üì¶
                ‚Üì
        (No transfer needed!) ‚úÖ
                ‚Üì
Contract ‚Üí Deposit to Staking
```

**Gas Savings:** Eliminates the `transferFrom` call = **~50,000 gas saved**

### Key Changes

1. **Generate calldata with contract as recipient:**
   ```javascript
   sender: '0xYourContractAddress' // Instead of user address
   ```

2. **Check contract balance instead of user balance:**
   ```solidity
   // Before
   uint256 userRifBalanceBefore = IERC20(RIF_TOKEN).balanceOf(msg.sender);

   // After
   uint256 rifBalanceBefore = IERC20(RIF_TOKEN).balanceOf(address(this));
   ```

3. **No transferFrom needed:**
   ```solidity
   // OLD (line 52 of original):
   IERC20(RIF_TOKEN).transferFrom(msg.sender, address(this), rifReceived); ‚ùå

   // NEW:
   // RIF is already in the contract! Just approve and stake ‚úÖ
   ```

## Testing Strategy

### Challenge

> "But before deploying I will not be able to test"

**Problem:** If the calldata routes tokens to the contract address, but you don't know the contract address until after deployment, how do you test?

### Solution 1: Deploy First, Then Generate Calldata (Recommended)

1. Deploy `RIFDepositerOptimized` to testnet/mainnet
2. Note the deployed contract address
3. Generate calldata using that address:
   ```bash
   node Script/generate-calldata-optimized.js
   ```
4. Update the `CONTRACT_ADDRESS` constant in the script
5. Use the generated calldata in production

### Solution 2: Use Configurable Recipient Function

For more flexible testing, use `executeCallsAndDepositWithRecipient()`:

```solidity
function executeCallsAndDepositWithRecipient(
    address[] calldata tokens,
    uint256[] calldata amounts,
    bytes[] calldata callDataArray,
    address recipient  // ‚Üê Specify who receives swap output
) external
```

**Testing workflow:**
```javascript
// 1. For local testing - route to whale or test address
generateSwapCalldata(RUSDT, amount, WHALE_ADDRESS);

// 2. Deploy contract
const contract = await deploy('RIFDepositerOptimized');

// 3. For production - route to contract
generateSwapCalldata(RUSDT, amount, contract.address);
```

### Solution 3: Hardhat/Foundry Testing

In Foundry tests, you can deploy first then generate:

```solidity
function setUp() public {
    // 1. Deploy contract
    optimizedContract = new RIFDepositerOptimized();

    // 2. Note: address(optimizedContract) is now known
    // 3. Generate calldata with this address using the script
    // 4. Use that calldata in your tests
}
```

## Implementation Guide

### Step 1: Deploy the Optimized Contract

```bash
# Deploy to Rootstock
forge create src/RIFDepositerOptimized.sol:RIFDepositerOptimized \
  --rpc-url $RSK_RPC_URL \
  --private-key $PRIVATE_KEY
```

### Step 2: Update Calldata Script

Edit `Script/generate-calldata-optimized.js`:

```javascript
// Replace with your deployed contract address
const CONTRACT_ADDRESS = '0xYourDeployedContractAddress';
```

### Step 3: Generate Production Calldata

```bash
cd Script
node generate-calldata-optimized.js
```

Output:
```
========================================
PRODUCTION CALLDATA (Gas Optimized)
========================================

üì¶ Production rUSDT -> RIF Calldata
Recipient: 0xYourContractAddress
Calldata: 0x...

üì¶ Production USDT -> RIF Calldata
Recipient: 0xYourContractAddress
Calldata: 0x...
```

### Step 4: Use in Your Frontend

```typescript
// Frontend/src/hooks/useBatchTransaction.ts
const calldataArray = [
  '0x...', // Generated calldata for token 1
  '0x...', // Generated calldata for token 2
];

await contract.executeCallsAndDeposit(
  [RUSDT, USDT],
  [amount1, amount2],
  calldataArray
);
```

## Gas Comparison

### Original Contract Gas Breakdown

| Operation | Gas Cost |
|-----------|----------|
| Transfer input tokens | ~46,000 per token |
| Approve router | ~46,000 per token |
| Execute swaps | ~varies |
| Check user balance | ~2,600 |
| **transferFrom RIF (user ‚Üí contract)** | **~50,000** ‚ùå |
| Approve staking | ~46,000 |
| Deposit to staking | ~varies |
| **TOTAL** | **~varies** |

### Optimized Contract Gas Breakdown

| Operation | Gas Cost |
|-----------|----------|
| Transfer input tokens | ~46,000 per token |
| Approve router | ~46,000 per token |
| Execute swaps | ~varies |
| Check contract balance | ~2,600 |
| **transferFrom RIF** | **ELIMINATED** ‚úÖ |
| Approve staking | ~46,000 |
| Deposit to staking | ~varies |
| **TOTAL** | **~50k less** |

### Real-World Savings

For a transaction with 2 token swaps:
- **Original:** ~450,000 gas
- **Optimized:** ~400,000 gas
- **Savings:** ~50,000 gas (11% reduction)

At 0.06 gwei gas price and $60,000 BTC:
- **Savings per transaction:** ~$0.18
- **Savings per 1000 transactions:** ~$180

## Testing Gas Savings

Run the test suite to verify gas savings:

```bash
# Run gas comparison test
forge test --match-test testGasComparison -vv --fork-url $RSK_RPC_URL

# Run individual tests
forge test --match-test testOriginalApproach_RUSDT -vv --fork-url $RSK_RPC_URL
forge test --match-test testOptimizedApproach_RUSDT -vv --fork-url $RSK_RPC_URL
```

Expected output:
```
Original Approach Gas Used: ~450,000
Optimized Approach Gas Used: ~400,000
Gas Savings: ~50,000 (11%)
```

## Important Notes

### Calldata Must Route to Contract

The optimization **only works** if your calldata routes RIF tokens to the contract address:

```javascript
// ‚úÖ CORRECT
sender: '0xYourRIFDepositerOptimizedAddress'

// ‚ùå WRONG - will fail because contract expects RIF in itself
sender: '0xUserAddress'
```

### User Must Still Approve Input Tokens

Users still need to approve the contract for input tokens (RUSDT, USDT, etc.):

```javascript
await rusdtContract.approve(rifDepositerOptimizedAddress, amount);
```

### User Does NOT Need to Approve RIF

With the optimization, users **no longer need to approve RIF tokens** because:
1. RIF never goes to their wallet
2. RIF goes directly from Sushi Router to the contract
3. Contract handles staking internally

**This is also a UX improvement!** One less approval transaction.

## Migration from Original Contract

If you're currently using `RIFDepositer.sol`:

1. Deploy `RIFDepositerOptimized.sol`
2. Update frontend to use new contract address
3. Regenerate calldata with new contract as recipient
4. Update frontend to use new calldata
5. Remove RIF approval step from frontend (no longer needed!)

**No changes needed for:**
- Input token approvals (RUSDT, USDT, etc.)
- Staking contract interaction
- User experience (except one less approval!)

## Security Considerations

### No Additional Risk

The optimization introduces **no new security risks**:
- Same input validation
- Same approval patterns for input tokens
- Same staking flow
- Same access controls

### Audit Checklist

- ‚úÖ Input tokens still pulled from user with `transferFrom`
- ‚úÖ Router still approved only for specific amounts
- ‚úÖ Balance checks prevent reentrancy issues
- ‚úÖ Staking contract still deposits for `msg.sender`
- ‚úÖ No ether handling (no selfdestruct concerns)
- ‚úÖ No delegatecall usage

## Conclusion

**Benefits:**
- ‚úÖ Saves ~50,000 gas per transaction (11% reduction)
- ‚úÖ Better UX (one less approval needed)
- ‚úÖ Same security properties
- ‚úÖ Fully testable with proper workflow

**Trade-offs:**
- ‚ö†Ô∏è Must deploy contract before generating production calldata
- ‚ö†Ô∏è Calldata is specific to contract address

**Recommendation:** Use `RIFDepositerOptimized.sol` for all new deployments to maximize gas efficiency and improve user experience.

## Questions?

- Check the test file: `test/RIFDepositerOptimizedTest.t.sol`
- Review the calldata script: `Script/generate-calldata-optimized.js`
- Compare contracts: `src/RIFDepositer.sol` vs `src/RIFDepositerOptimized.sol`
